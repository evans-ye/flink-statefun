# Adding Smoke E2E for a Language SDK
For the steps below, take _statefun-smoke-e2e-golang_ module as a reference implementation. You can copy the static config/protobuf files from there.

## Implementation
### Step 1: Create a new module and generate the protobuf bindings
* Create a new module named _statefun-smoke-e2e-LANGUAGE_ under _statefun-e2e-tests_.
* Make _statefun-smoke-e2e-multilang-base_ as parent of the created module in ``pom.xml``:
```
    <parent>
        <groupId>org.apache.flink</groupId>
        <artifactId>statefun-smoke-e2e-multilang-base</artifactId>
        <version>3.1-SNAPSHOT</version>
        <relativePath>../statefun-smoke-e2e-multilang-base/pom.xml</relativePath>
    </parent>
```
* Copy ``commands.proto`` from the reference implementation into the created module under ``src/main/protobuf``. 
* Make language specific changes to the ``commands.proto``. For example, the following line is added into ``commands.proto`` to generate GoLang bindings.
```
option go_package = ".;app";
```
* Generate language specific protobuf bindings under ``src/main/LANGUAGE`` for functions to utilize.
* Copy ``remote-module/module.yaml``, ``Dockerfile``, ``log4j.properties`` into ``src/test/resources``. These files are for launching the Smoke E2E driver, hence no code change needed.

### Step 2: Implement the CommandInterpreterFn as an HTTP endpoint
* ``CommandInterpreterFn`` is a remote function that performs the operation based on the command received. Following is the high level introduction to the logic to be implemented in the function. One can also look into other Smoke E2E's implementation for reference.
  * The function receives ``SourceCommand``s generated by the ``CommandGenerator``(see details in _statefun-smoke-e2e-driver_).
  * The function extract ``Commands`` from the ``SourceCommand``, and perform corresponding operations based on the command types:
    * ``Command.Send``: send the wrapped ``Commands`` to the target address.
    * ``Command.SendAfter``: send the wrapped ``Commands`` to the target address after a certain delay of time(defined as a constant, say, 1 millisecond).
    * ``Command.IncrementState``: increment the counter(state) by 1.
    * ``Command.SendEgress``: send a message to the ``DISCARD_EGRESS``. The message can be just a simple string with whatever content.
    * ``Command.Verify``: build a ``VerificationResult`` by filling in the expected count from the ``Command.Verify``, and the actual count from function's counter(state). Then, send it over to the ``VERIFICATION_EGRESS``.
  * Make sure the typename of the function, messages, and ingress/egress are all aligned with the driver's definition. For example, the typename of ``VerificationResult`` should be _statefun.smoke.e2e/verification-result_. You can find all the naming in ``Constants`` under _statefun-smoke-e2e-driver_.
* Finally, wrap the ``CommandInterpreterFn`` as an HTTP endpoint using a simple web container. The endpoint should listen on 8000 port(aligned with the ``module.yaml`` setting).

### Step 3: Orchestrate pieces into a SmokeVerificationE2E
* Create a language specific ``SmokeVerificationE2E`` under ``src/test/java``. You should mostly focus on preparing resources for launching the language specific HTTP endpoint in the ``configureRemoteFunction`` method. The rest of the parts can just be copied from other Smoke E2E implementations.
* Next, create a ``Dockerfile.remote-function`` under ``src/test/resources``, which builds the resources prepared by ``SmokeVerificationE2E`` into a Docker image. The image is then launched as an HTTP endpoint inside the container serving the ``CommandInterpreterFn``.

^^^^^^ DONE ^^^^

## Execution
### Run the Harness test
* Run Step 3's ``CommandInterpreterFn`` HTTP endpoint at localhost 8000 port.
* Run ``MultiLangSmokeHarnessTest`` under _statefun-smoke-e2e-multilang-harness_ to test out your implementation.

## Run the Smoke E2E test

# Architecture

```
Flnik StateFun cluster -> SimpleVerificationServer
    (Containers)              (Junit Process)
          ^
          |
          Ë‡
   Remote Function
    (Container)
```

The ``SmokeRunner`` orchestrates the entire Smoke E2E runtime and does the following:
* Launch the Flink StateFun cluster and the remote function, those aredefined by ``StatefulFunctionsAppContainers.Builder`` and passed to the ``SmokeRunner``. The detailed configuration can be found in concrete implementation such as SmokeVerificationJavaE2E
* The ``CommandGenerator`` wrapped by ``CommandFlinkSource`` starts to generate commands and then sent over to the remote functions for state manipulations(counters). At the same time it also applies the command internally to its internal states.
* After commands are generated, The ``CommandFlinkSource`` enters the verification stage and starts to send out ``VerificationResult`` messages along with the counts stored in its internal states as expected counts.
* The remote functions received ``VerificationResult`` messages and attach the counts from states as actual counts.
* The ``VerificationResult`` messages are then sent to ``SocketClientSink``, and further sent to ``SimpleVerificationServer`` that collects the verification results.
* The ``awaitVerificationSuccess`` method in ``SmokeRunner`` keeps polling the result arrived at ``SimpleVerificationServer`` and verifies it by simply doing actual == expected. When all the messages are successfully verified. The program exits.

# Framework Modules
## statefun-smoke-e2e-driver
The core logic of the testing framework which generates a series of command and verification messages via ``CommandGenerator``.
The driver code here is built into a self-contained jar that can be loaded and ran by the Flink StateFun cluster directly. 

## statefun-smoke-e2e-multilang-base
This module contains a generic ``pom.xml`` that have the dependencies and the driver jar downloaded to run Smoke E2E.

## statefun-smoke-e2e-multilang-harness
The harness test that can be ran directly by JUnit. Noted that one should have a remote function running at localhost 8000 port before running the harness test.
# Adding Smoke E2E for a Language SDK
For the steps below, take _statefun-smoke-e2e-golang_ module as a reference implementation. You can copy the static config/protobuf files from there.

## Implementation
### Step 1: Create a new module and generate the protobuf bindings
* Create a new module named _statefun-smoke-e2e-LANGUAGE_ under _statefun-e2e-tests_.
* Make _statefun-smoke-e2e-multilang-base_ as parent of the created module in ``pom.xml``:
```
    <parent>
        <groupId>org.apache.flink</groupId>
        <artifactId>statefun-smoke-e2e-multilang-base</artifactId>
        <version>3.1-SNAPSHOT</version>
        <relativePath>../statefun-smoke-e2e-multilang-base/pom.xml</relativePath>
    </parent>
```
* Copy ``commands.proto`` from the reference implementation into the created module under ``src/main/protobuf``. 
* Make language specific changes to the ``commands.proto``. For example, the following line is added into ``commands.proto`` to generate GoLang bindings.
```
option go_package = ".;app";
```
* Generate language specific protobuf bindings under ``src/main/LANGUAGE``. This allows the function to serialize/deserialize the messages sent/received.
* Copy ``remote-module/module.yaml``, ``Dockerfile``, ``log4j.properties`` into ``src/test/resources``. These files are for launching the Smoke E2E driver, hence no code changes needed.

### Step 2: Implement the CommandInterpreterFn as an HTTP endpoint
* ``CommandInterpreterFn`` is a remote function that performs the operation based on the command received. Following is the high level introduction to the logic to be implemented in the function. One can also look into other Smoke E2E's implementation for reference.
  * The function receives ``SourceCommand``s generated by the ``CommandGenerator``(see details in _statefun-smoke-e2e-driver_).
  * The function extracts ``Commands`` from the ``SourceCommand``, and performs corresponding operations based on the command types:
    * ``Command.Send``: send the enclosing ``Commands`` to the target address.
    * ``Command.SendAfter``: send the enclosing ``Commands`` to the target address after a certain delay of time(defined as a constant, say, 1 millisecond).
    * ``Command.IncrementState``: increment the counter(state) by 1.
    * ``Command.SendEgress``: send a message to the ``DISCARD_EGRESS``. The message can be just a simple string with whatever content.
    * ``Command.Verify``: build a ``VerificationResult`` by filling in the expected count from the ``Command.Verify``, and the actual count from function's counter(state). Then, send it over to the ``VERIFICATION_EGRESS``.
  * Make sure the typename of the function, messages, and ingress/egress are all aligned with the driver's definition. For example, the typename of ``VerificationResult`` should be _statefun.smoke.e2e/verification-result_. Think of the typename is the unique identifier of messages across different language bindings. You can find all the naming in ``Constants`` under _statefun-smoke-e2e-driver_.
* Finally, wrap the ``CommandInterpreterFn`` as an HTTP endpoint using a simple web container. The endpoint should listen on 8000 port(aligned with the ``module.yaml`` setting).

### Step 3: Orchestrate pieces into a SmokeVerificationE2E
* Create a language specific ``SmokeVerificationE2E`` under ``src/test/java``. Most of the code can just be copied from other Smoke E2E implementations. Particularly, you should focus on preparing resources for launching the language specific HTTP endpoint in the ``configureRemoteFunction`` method.
* Next, create a ``Dockerfile.remote-function`` under ``src/test/resources``, which builds the resources prepared by ``SmokeVerificationE2E`` into a Docker image. The image is then launched as an HTTP endpoint inside the container serving the ``CommandInterpreterFn``.

## Execution
### Run the Harness test
* The Harness test is to run the Smoke E2E test as a JUnit process against the remote function. A nice feature it provides is you can run both the Harness and the remote function on IDE, therefore allows you can mark breakpoints on either the Smoke E2E process or the remote function process.
^^^ TO THIS END ^^^
* To run the harness test against different language SDK:
  * Startup the HTTP endpoint that serve the remote function(implemented in Step 2) at 
  * ``MultiLangSmokeHarnessTest`` under _statefun-smoke-e2e-multilang-harness
* Run Step 3's ``CommandInterpreterFn`` HTTP endpoint at localhost 8000 port.
_ to test out your implementation.

## Run the Smoke E2E test

# Architecture

```
Flnik StateFun cluster -> SimpleVerificationServer
    (Containers)              (JUnit Process)
          ^
          |
          Ë‡
   Remote Function
    (Container)
```

The ``SmokeRunner`` orchestrates the entire Smoke E2E runtime and does the following:
* Launch the Flink StateFun cluster and the remote function, those aredefined by ``StatefulFunctionsAppContainers.Builder`` and passed to the ``SmokeRunner``. The detailed configuration can be found in concrete implementation such as SmokeVerificationJavaE2E
* The ``CommandGenerator`` wrapped by ``CommandFlinkSource`` starts to generate commands and then sent over to the remote functions for state manipulations(counters). At the same time it also applies the command internally to its internal states.
* After commands are generated, The ``CommandFlinkSource`` enters the verification stage and starts to send out ``VerificationResult`` messages along with the counts stored in its internal states as expected counts.
* The remote functions received ``VerificationResult`` messages and attach the counts from states as actual counts.
* The ``VerificationResult`` messages are then sent to ``SocketClientSink``, and further sent to ``SimpleVerificationServer`` that collects the verification results.
* The ``awaitVerificationSuccess`` method in ``SmokeRunner`` keeps polling the result arrived at ``SimpleVerificationServer`` and verifies it by simply doing actual == expected. When all the messages are successfully verified. The program exits.

# Framework Modules

## _statefun-smoke-e2e-common_
Testing utilities:
* ``SmokeRunner``: facet class that organizes the Smoke E2E runtime architecture.
* ``SimpleVerificationServer``: receives the ``VerificationResult`` messages and performs the verification.

## _statefun-smoke-e2e-driver_
The core logic of the testing framework which generates a series of command and verification messages via ``CommandGenerator``.
The driver code here is built into a self-contained jar that can be loaded and ran by the Flink StateFun cluster directly. 

## _statefun-smoke-e2e-multilang-base_
This module contains a generic ``pom.xml`` that have the dependencies and the driver jar downloaded to run Smoke E2E.

## _statefun-smoke-e2e-multilang-harness_
The harness test that can be ran directly by JUnit. Noted that one should have a remote function running at localhost 8000 port before running the harness test.